function [varargout] = jigsawgeo(opts)
%JIGSAWGEO an interface for the JIGSAW-GEO grid-generator.
%   [GRID] = JIGSAWGEO(OPTS) calls the JIGSAW mesh-generator 
%   using the configuration options specified in the OPTS 
%   structure. GRID is general-purpose mesh container, stor-
%   ing the vertices and elements associated with a two- or 
%   three-dimensional tessellation. See READMSH for details.
%
%   OPTS is a user-defined structure of meshing options:
%
%   REQUIRED fields:
%   ---------------
%
% - OPTS.GEOM_FILE - 'GEOMNAME.GEO', a string containing the 
%   name of the geometry file (is required at input).
%
% - OPTS.JCFG_FILE - 'JCFGNAME.JIG', a string containing the 
%   name of the config file (will be created on output).
%
% - OPTS.MESH_FILE - 'MESHNAME.MSH', a string containing the 
%   name of the output file (will be created on output).
%
% - OPTS.HFUN_FILE - 'HFUNNAME.DAT', a string containing the 
%   name of the grid-length file (is required at input). 
%
%   OPTIONAL fields (MESH):
%   ----------------------
%
% - OPTS.MESH_KERN - {default='delfront'} meshing kernal se-
%   lection, choice of the standard Delaunay-refinement tec-
%   hnique (KERN='delaunay') or the Frontal-Delaunay method 
%   (KERN='delfront').
%
% - OPTS.MESH_ITER - {default=+INF} max. number of mesh ref-
%   inement iterations. Set ITER = N to see progress after N 
%   iterations. 
%
% - OPTS.MESH_RAD2 - {default=1.05} max. radius-edge ratio 
%   for 2-tria elements. 2-trias are refined until the ratio 
%   of the element circumradius to min. edge length is less-
%   than MESH_RAD2 .
%
%   OPTIONAL FIELDS (MISC):
%   ----------------------
%
% - OPTS.VERBOSITY - {default=0} verbosity of logfile output 
%   generated by JIGSAW. Set VERBOSITY>=1 to display additi-
%   onal output.
%
%   See also READMSH, MAKEMSH, DRAWMESH, MESHCOST, DRAWCOST
%

%   JIGSAW-GEO is an unstructured mesh generator for the co-
%   nstruction of locally-orthogonal staggered unstructured 
%   grids for geophysical applications on the sphere. Speci-
%   fically, JIGSAW-GEO supports the generation of 
%   guaranteed-quality Voronoi/Delaunay grids appropriate to
%   multi-resolution general-circulation modelling.
%
%   JIGSAW-GEO is based on combination of restricted Frontal
%   Delaunay-refinement and "hill-climbing" type mesh optim-
%   isation algorithms. See the following for more detail:
%    
%   Engwirda, D. "Locally-orthognal unstructured grid-gener-
%   ation for general circulation modelling on the sphere", 
%   2016, https://arxiv.org/abs/1611.08996
%
%   See the fulltext articles for additional information and 
%   references.
%

%-----------------------------------------------------------
%   Darren Engwirda : 2017 --
%   Email           : engwirda@mit.edu
%   Last updated    : 20/04/2017
%-----------------------------------------------------------
%

    jexename = '';

    if ( isempty(opts))
        error('JIGSAW: insufficient inputs.');
    end
    
    if (~isempty(opts) && ~isstruct(opts))
        error('JIGSAW: invalid input types.');
    end

%---------------------------------- write OP to config. file        
    makejig(opts.jcfg_file,opts);
    
    filename = mfilename('fullpath');
    filepath = fileparts( filename );

%---------------------------------- default to _debug binary
    if (strcmp(jexename,''))
    if (ispc())
        jexename = [filepath, ...
    '\jigsaw-geo\bin\WIN-64\jigsaw-geo64d.exe'];
    elseif (ismac ())
        jexename = [filepath, ...
    '/jigsaw-geo/bin/MAC-64/jigsaw-geo64d'];
    elseif (isunix())
        jexename = [filepath, ...
    '/jigsaw-geo/bin/GLX-64/jigsaw-geo64d'];
    end
    end
    
    if (exist(jexename,'file')~=2), jexename=''; end
    
%---------------------------------- switch to release binary
    if (strcmp(jexename,''))
    if (ispc())
        jexename = [filepath, ...
    '\jigsaw-geo\bin\WIN-64\jigsaw-geo64r.exe'];
    elseif (ismac ())
        jexename = [filepath, ...
    '/jigsaw-geo/bin/MAC-64/jigsaw-geo64r'];
    elseif (isunix())
        jexename = [filepath, ...
    '/jigsaw-geo/bin/GLX-64/jigsaw-geo64r'];
    end
    end
  
    jexetext = [jexename,' ',opts.jcfg_file];
    
%---------------------------- call JIGSAW and capture stdout
    if (exist(jexename,'file') == +2)
   
   [status, result] = system(jexetext, '-echo') ;
   
%---------------------------- OCTAVE doesn't handle '-echo'!
    if (exist('OCTAVE_VERSION', 'builtin') > 0)
        fprintf(1,'%s',result) ;
    end
    
    else
    error('JIGSAW: executable not found.') ;
    end

    if (nargout == +1)
%---------------------------- read mesh if output requested!
    varargout{1} = readmsh(opts.mesh_file) ;
    end
    
end

function makejig(name,opts)
%MAKEJIG make *.JIG config. file for JIGSAW.

   [path,file,fext] = fileparts(name) ;

    if(~strcmp(lower(fext),'.jig'))
        error('Invalid file name');
    end

%-------------------------------------------- default param.
    if (~isfield(opts,'mesh_dims'))
        opts.mesh_dims = + 2 ;
    end
    if (~isfield(opts,'mesh_snk2'))
        opts.mesh_snk2 = +.1 ;
    end

    try
   
    ffid = fopen(name, 'w' ) ;
   
    fprintf(ffid,'# %s.jig config. file for JIGSAW\r\n',file);
    
    data = fieldnames (opts) ;
    data = sort(data) ;
    
    for ii = +1:length(data) 
        
    switch (lower(data{ii})) 
        case 'verbosity'
        pushints(ffid,opts.verbosity,'verbosity');
    %------------------------------------------ FILE options
        case 'jcfg_file' ;
        case 'geom_file'
        pushchar(ffid,opts.geom_file,'geom_file');
        
        case 'mesh_file'
        pushchar(ffid,opts.mesh_file,'mesh_file');
        
        case 'hfun_file'
        pushchar(ffid,opts.hfun_file,'hfun_file');
        
    %------------------------------------------ GEOM options
        case 'geom_seed'
        pushints(ffid,opts.geom_seed,'geom_seed');
        
        case 'geom_feat'
        pushbool(ffid,opts.geom_feat,'geom_feat');
        
        case 'geom_phi1'
        pushreal(ffid,opts.geom_phi1,'geom_phi1');
        case 'geom_phi2'
        pushreal(ffid,opts.geom_phi2,'geom_phi2');
        
        case 'geom_eta1'
        pushreal(ffid,opts.geom_eta1,'geom_eta1');
        case 'geom_eta2'
        pushreal(ffid,opts.geom_eta2,'geom_eta2');
        
    %------------------------------------------ MESH options
        case 'mesh_kern'
        pushchar(ffid,opts.mesh_kern,'mesh_kern');
        
        case 'mesh_iter'
        pushints(ffid,opts.mesh_iter,'mesh_iter');
        
        case 'mesh_dims'
        pushints(ffid,opts.mesh_dims,'mesh_dims');
        
        case 'mesh_top1'
        pushbool(ffid,opts.mesh_top1,'mesh_top1');
        case 'mesh_top2'
        pushbool(ffid,opts.mesh_top2,'mesh_top2');
        
        case 'mesh_siz1'
        pushreal(ffid,opts.mesh_siz1,'mesh_siz1');
        case 'mesh_siz2'
        pushreal(ffid,opts.mesh_siz2,'mesh_siz2');
        case 'mesh_siz3'
        pushreal(ffid,opts.mesh_siz3,'mesh_siz3');
        
        case 'mesh_eps1'
        pushreal(ffid,opts.mesh_eps1,'mesh_eps1');
        case 'mesh_eps2'
        pushreal(ffid,opts.mesh_eps2,'mesh_eps2');
        
        case 'mesh_rad2'
        pushreal(ffid,opts.mesh_rad2,'mesh_rad2');
        case 'mesh_rad3'
        pushreal(ffid,opts.mesh_rad3,'mesh_rad3');
        
        case 'mesh_off2'
        pushreal(ffid,opts.mesh_off2,'mesh_off2');
        case 'mesh_off3'
        pushreal(ffid,opts.mesh_off3,'mesh_off3');
        
        case 'mesh_snk2'
        pushreal(ffid,opts.mesh_snk2,'mesh_snk2');
        case 'mesh_snk3'
        pushreal(ffid,opts.mesh_snk3,'mesh_snk3');
        
        case 'mesh_vol3'
        pushreal(ffid,opts.mesh_vol3,'mesh_vol3');

        case{'hfun_kern','hfun_scal', ...
             'hfun_grad', ...
             'hfun_hmin','hfun_hmax'}
        warning( ...
        ['Deprecated!!: OPTS.', upper(data{ii})]);

        otherwise
        error  ( ...
        ['Invalid data: OPTS.', upper(data{ii})]);
    end
        
    end

    fclose(ffid);

    catch   err
    
    if (ffid>-1)
    fclose(ffid);
    end
    
    rethrow(err);
    
    end
    
end

function pushbool(ffid,data,name)
%PUSHBOOL push "bool" data onto JCFG file.

    if (islogical(data))
        if (data)
            pushchar(ffid,'true' ,name);
        else
            pushchar(ffid,'false',name);
        end
    else
        error(['Incorrect type: OPTS.',upper(name)]) ;
    end

end

function pushchar(ffid,data,name)
%PUSHCHAR push "char" data onto JCFG file.

    if (ischar(data))
        fprintf(ffid,['  ',name,'=%s\n'],data);
    else
        error(['Incorrect type: OPTS.',upper(name)]) ;
    end

end

function pushints(ffid,data,name)
%PUSHINTS push "_INT" data onto JCFG file.

    if (isnumeric(data))
        if (numel(data)==+1)
        fprintf(ffid,['  ',name,'=%i\n'],data);
        else
        error(['Incorrect dims: OPTS.',upper(name)]) ;
        end
    else
        error(['Incorrect type: OPTS.',upper(name)]) ;
    end

end

function pushreal(ffid,data,name)
%PUSHREAL push "real" data onto JCFG file.

    if (isnumeric(data))
        if (numel(data)==+1)
        fprintf(ffid,['  ',name,'=%1.16g\n'],data);
        else
        error(['Incorrect dims: OPTS.',upper(name)]) ;
        end
    else
        error(['Incorrect type: OPTS.',upper(name)]) ;
    end
    
end



